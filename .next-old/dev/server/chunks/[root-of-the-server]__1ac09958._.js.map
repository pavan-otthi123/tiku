{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///Users/muraliotthi/Documents/tiku/lib/db.ts"],"sourcesContent":["import { sql } from \"@vercel/postgres\";\nimport { TimelineEvent, Photo } from \"./types\";\n\nlet tablesInitialized = false;\n\nexport async function ensureTables(): Promise<void> {\n  if (tablesInitialized) return;\n\n  await sql`\n    CREATE TABLE IF NOT EXISTS events (\n      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n      title VARCHAR(255) NOT NULL,\n      date DATE NOT NULL,\n      created_at TIMESTAMPTZ DEFAULT NOW(),\n      updated_at TIMESTAMPTZ DEFAULT NOW()\n    )\n  `;\n\n  await sql`\n    CREATE TABLE IF NOT EXISTS photos (\n      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n      event_id UUID NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n      url TEXT NOT NULL,\n      sort_order INTEGER DEFAULT 0,\n      created_at TIMESTAMPTZ DEFAULT NOW()\n    )\n  `;\n\n  tablesInitialized = true;\n}\n\nexport async function getAllEvents(): Promise<TimelineEvent[]> {\n  await ensureTables();\n\n  const eventsResult = await sql`\n    SELECT id, title, date::text, created_at, updated_at\n    FROM events\n    ORDER BY date ASC\n  `;\n\n  const photosResult = await sql`\n    SELECT id, event_id, url, sort_order, created_at\n    FROM photos\n    ORDER BY sort_order ASC, created_at ASC\n  `;\n\n  const photosByEvent: Record<string, Photo[]> = {};\n  for (const row of photosResult.rows) {\n    const eventId = row.event_id;\n    if (!photosByEvent[eventId]) photosByEvent[eventId] = [];\n    photosByEvent[eventId].push({\n      id: row.id,\n      event_id: row.event_id,\n      url: row.url,\n      sort_order: row.sort_order,\n      created_at: row.created_at,\n    });\n  }\n\n  return eventsResult.rows.map((row) => ({\n    id: row.id,\n    title: row.title,\n    date: row.date,\n    created_at: row.created_at,\n    updated_at: row.updated_at,\n    photos: photosByEvent[row.id] || [],\n  }));\n}\n\nexport async function getEvent(id: string): Promise<TimelineEvent | null> {\n  await ensureTables();\n\n  const eventResult = await sql`\n    SELECT id, title, date::text, created_at, updated_at\n    FROM events WHERE id = ${id}\n  `;\n\n  if (eventResult.rows.length === 0) return null;\n\n  const photosResult = await sql`\n    SELECT id, event_id, url, sort_order, created_at\n    FROM photos WHERE event_id = ${id}\n    ORDER BY sort_order ASC, created_at ASC\n  `;\n\n  const row = eventResult.rows[0];\n  return {\n    id: row.id,\n    title: row.title,\n    date: row.date,\n    created_at: row.created_at,\n    updated_at: row.updated_at,\n    photos: photosResult.rows.map((p) => ({\n      id: p.id,\n      event_id: p.event_id,\n      url: p.url,\n      sort_order: p.sort_order,\n      created_at: p.created_at,\n    })),\n  };\n}\n\nexport async function createEvent(\n  title: string,\n  date: string\n): Promise<TimelineEvent> {\n  await ensureTables();\n\n  const result = await sql`\n    INSERT INTO events (title, date)\n    VALUES (${title}, ${date})\n    RETURNING id, title, date::text, created_at, updated_at\n  `;\n\n  const row = result.rows[0];\n  return {\n    id: row.id,\n    title: row.title,\n    date: row.date,\n    created_at: row.created_at,\n    updated_at: row.updated_at,\n    photos: [],\n  };\n}\n\nexport async function updateEvent(\n  id: string,\n  title: string,\n  date: string\n): Promise<TimelineEvent | null> {\n  await ensureTables();\n\n  const result = await sql`\n    UPDATE events SET title = ${title}, date = ${date}, updated_at = NOW()\n    WHERE id = ${id}\n    RETURNING id, title, date::text, created_at, updated_at\n  `;\n\n  if (result.rows.length === 0) return null;\n\n  const photosResult = await sql`\n    SELECT id, event_id, url, sort_order, created_at\n    FROM photos WHERE event_id = ${id}\n    ORDER BY sort_order ASC, created_at ASC\n  `;\n\n  const row = result.rows[0];\n  return {\n    id: row.id,\n    title: row.title,\n    date: row.date,\n    created_at: row.created_at,\n    updated_at: row.updated_at,\n    photos: photosResult.rows.map((p) => ({\n      id: p.id,\n      event_id: p.event_id,\n      url: p.url,\n      sort_order: p.sort_order,\n      created_at: p.created_at,\n    })),\n  };\n}\n\nexport async function deleteEvent(id: string): Promise<boolean> {\n  await ensureTables();\n  const result = await sql`DELETE FROM events WHERE id = ${id}`;\n  return (result.rowCount ?? 0) > 0;\n}\n\nexport async function addPhoto(\n  eventId: string,\n  url: string,\n  sortOrder: number = 0\n): Promise<Photo> {\n  await ensureTables();\n\n  const result = await sql`\n    INSERT INTO photos (event_id, url, sort_order)\n    VALUES (${eventId}, ${url}, ${sortOrder})\n    RETURNING id, event_id, url, sort_order, created_at\n  `;\n\n  const row = result.rows[0];\n  return {\n    id: row.id,\n    event_id: row.event_id,\n    url: row.url,\n    sort_order: row.sort_order,\n    created_at: row.created_at,\n  };\n}\n\nexport async function removePhoto(photoId: string): Promise<boolean> {\n  await ensureTables();\n  const result = await sql`DELETE FROM photos WHERE id = ${photoId}`;\n  return (result.rowCount ?? 0) > 0;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":["file:///Users/muraliotthi/Documents/tiku/app/api/events/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { getAllEvents, createEvent } from \"@/lib/db\";\n\nexport async function GET() {\n  try {\n    const events = await getAllEvents();\n    return NextResponse.json({ events });\n  } catch (error: unknown) {\n    console.error(\"Error fetching events:\", error);\n    const message =\n      error instanceof Error ? error.message : \"Failed to fetch events\";\n    return NextResponse.json({ error: message, events: [] }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { title, date } = await request.json();\n\n    if (!title || !date) {\n      return NextResponse.json(\n        { error: \"Title and date are required\" },\n        { status: 400 }\n      );\n    }\n\n    const event = await createEvent(title, date);\n    return NextResponse.json({ event }, { status: 201 });\n  } catch (error: unknown) {\n    console.error(\"Error creating event:\", error);\n    const message =\n      error instanceof Error ? error.message : \"Failed to create event\";\n    return NextResponse.json({ error: message }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,SAAS,MAAM,IAAA,gJAAY;QACjC,OAAO,qKAAY,CAAC,IAAI,CAAC;YAAE;QAAO;IACpC,EAAE,OAAO,OAAgB;QACvB,QAAQ,KAAK,CAAC,0BAA0B;QACxC,MAAM,UACJ,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC3C,OAAO,qKAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAAS,QAAQ,EAAE;QAAC,GAAG;YAAE,QAAQ;QAAI;IACzE;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE1C,IAAI,CAAC,SAAS,CAAC,MAAM;YACnB,OAAO,qKAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,QAAQ,MAAM,IAAA,+IAAW,EAAC,OAAO;QACvC,OAAO,qKAAY,CAAC,IAAI,CAAC;YAAE;QAAM,GAAG;YAAE,QAAQ;QAAI;IACpD,EAAE,OAAO,OAAgB;QACvB,QAAQ,KAAK,CAAC,yBAAyB;QACvC,MAAM,UACJ,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC3C,OAAO,qKAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAQ,GAAG;YAAE,QAAQ;QAAI;IAC7D;AACF"}}]
}